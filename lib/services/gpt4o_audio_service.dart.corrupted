
  /// ğŸ”Š ğŸ†• ê°œì„ ëœ ê³ í’ˆì§ˆ ìŒì„± ìƒì„± (OpenAI TTS Service í™œìš©)
  Future<String> _generateHighQualityAudioWithService({
    required String text,
    String voice = 'nova',
  }) async {
    try {
      // ğŸ†• ì£¼ì…ë°›ì€ TTS ì„œë¹„ìŠ¤ ì‚¬ìš©
      AppLogger.info('Gpt4oAudioService: Using OpenAI TTS Service for high-quality audio generation');
      
      final audioPath = await _ttsService.generateSpeech(
        text: text,
        voice: voice,
        model: 'tts-1-hd',
        responseFormat: 'mp3',
        speed: 1.0,
      );
      
      AppLogger.info('Gpt4oAudioService: High-quality audio generated via TTS service: $audioPath');
      return audioPath;
    } catch (e) {
      AppLogger.error('Gpt4oAudioService: Failed to generate audio via TTS service: $e');
      
      // ğŸ”„ í´ë°±: ê¸°ì¡´ ë°©ì‹ ì‚¬ìš©
      AppLogger.warning('Gpt4oAudioService: Falling back to direct TTS API call');
      return await _generateHighQualityAudioDirect(text: text, voice: voice);
    }
  }

  /// ğŸ”Š ê¸°ì¡´ ì§ì ‘ TTS API í˜¸ì¶œ ë°©ì‹ (í´ë°±ìš©)
  Future<String> _generateHighQualityAudioDirect({
    required String text,
    String voice = 'nova',
  }) async {
    final requestBody = jsonEncode({
      'model': 'tts-1-hd',
      'input': text,
      'voice': voice,
      'response_format': 'mp3',
      'speed': 1.0,
    });

    final response = await http.post(
      Uri.parse('https://api.openai.com/v1/audio/speech'),
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer $_apiKey',
      },
      body: requestBody,
    ).timeout(const Duration(seconds: 30));

    if (response.statusCode == 200) {
      final tempDir = await getTemporaryDirectory();
      final filePath = '${tempDir.path}/${_uuid.v4()}.mp3';
      final file = File(filePath);
      await file.writeAsBytes(response.bodyBytes);
      
      return filePath;
    } else {
      throw AppError(
        type: AppErrorType.server,
        code: response.statusCode.toString(),
        message: 'TTS-1-HD API ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        details: response.body,
      );
    }
  }

  /// ğŸ¨ ìŒì„± ìŠ¤íƒ€ì¼ ìµœì í™”
  String recommendVoiceStyle({
    required String emotionType,
    required String conversationType,
  }) {
    switch (conversationType) {
      case 'ìœ„ë¡œê°€ í•„ìš”í•  ë•Œ':
      case 'ê³ ë¯¼ê±°ë¦¬':
        return emotionType == 'sadness' ? 'shimmer' : 'nova';
      case 'ìë‘ê±°ë¦¬':
      case 'ì‹œì‹œì½œì½œ':
        return 'echo';
      case 'í™”ê°€ ë‚˜ìš”':
        return 'onyx';
      default:
        return 'alloy';
    }
  }

  /// ğŸ§  ìŒì„± ê¸°ë°˜ ê°ì • ë¶„ì„
  Future<Map<String, dynamic>> analyzeAudioEmotion(String audioFilePath) async {
    try {
      final transcription = await _transcribeAudio(audioFilePath);
      
      const analysisPrompt = '''
ë‹¤ìŒ ìŒì„± ëŒ€í™” í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì‚¬ìš©ìì˜ ê°ì • ìƒíƒœë¥¼ íŒŒì•…í•˜ì„¸ìš”.
ìŒì„±ìœ¼ë¡œ ì „ë‹¬ëœ ë‚´ìš©ì´ë¯€ë¡œ ë§ì˜ í†¤, ì†ë„, ê°ì •ì  ë‰˜ì•™ìŠ¤ë¥¼ ê³ ë ¤í•˜ì—¬ ë¶„ì„í•˜ì„¸ìš”.

JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{
  "emotion": "ì£¼ìš” ê°ì • (joy, sadness, anger, fear, surprise, neutral)",
  "intensity": "ê°ì • ê°•ë„ (1-10)",
  "confidence": "ë¶„ì„ í™•ì‹ ë„ (0.0-1.0)",
  "emotional_indicators": ["ê°ì •ì„ ë‚˜íƒ€ë‚´ëŠ” ì§€í‘œë“¤"],
  "recommended_response_tone": "ì¶”ì²œ ì‘ë‹µ í†¤"
}
''';

      final analysisResponse = await _generateAudioResponse(
        userMessage: '$analysisPrompt\n\në¶„ì„í•  í…ìŠ¤íŠ¸: $transcription',
        systemPrompt: 'ë‹¹ì‹ ì€ ìŒì„± ê¸°ë°˜ ê°ì • ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.',
      );

      try {
        return jsonDecode(analysisResponse);
      } catch (e) {
        return {
          'emotion': 'neutral',
          'intensity': 5,
          'confidence': 0.5,
          'emotional_indicators': ['ë¶„ì„ ì‹¤íŒ¨'],
          'recommended_response_tone': 'balanced',
          'raw_analysis': analysisResponse,
        };
      }
    } catch (e) {
      AppLogger.error('Gpt4oAudioService: Audio emotion analysis failed: $e');
      return {
        'emotion': 'neutral',
        'intensity': 1,
        'confidence': 0.0,
        'error': e.toString(),
      };
    }
  }

  /// ğŸ”„ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
  Future<void> dispose() async {
    AppLogger.info('Gpt4oAudioService: Disposing resources');
    // TTS ì„œë¹„ìŠ¤ëŠ” Providerì—ì„œ ê´€ë¦¬ë˜ë¯€ë¡œ ë³„ë„ dispose ë¶ˆí•„ìš”
  }
}
